import os
import random
import collections
import hashlib
import json
import yaml
from rdkit import Chem

class DataSetManager:
    """
    A DataSetManager object can generate a data set of evenly distributed complexes.

    Parameters
    ----------
    num: int
        Total amount of complexes that will be in the data set after all complexes were generated.
    gen_ligand: callable
        Function which returns smiles string of a ligand.
    gen_structure: callable
        Function which generates the structure of a complexe. Returns smiles if structure generation was successfull, else returns None.
    only_SMILES: bool, optional
        If the only_SMILES is set Flase, complexes are not embedded (default True).
    only_LA: bool, optional
        If the only_LA is set to True, fluoride adducts are generated additionaly (default False).
    ligand_poll_factor: int, optional
        The higher the ligand_poll_factor, the more balanced the donor atom count (default 2000).
        
    Attributes
    ----------
    num: int
        Total amount of complexes that will be in the data set after all complexes were generated.
    num_dict: dict
        Number of complexes of each category to be generated.
    central_atoms: dict
        Dictionary with all central atoms and their valencies.
    data: dict
        Dictionary containing information of generated complexes.
        Is generated by calling gen_complex().
    donor_dict: dict
        Type and amount of donors in each category of complexes.
        Is generated by calling gen_complex().
    only_SMILES: bool
        If the only_SMILES is set Flase, complexes are not embedded.
    only_LA: bool
        If the only_LA is set to True, fluoride adducts are generated additionaly.
    ligand_poll_factor: int
        The higher the ligand_poll_factor, the more balanced the donor atom count.

    Methods
    -------
    gen_complexes()
        Run complex generation.

    save(file_name)
        Save data to json file, num_dict to yaml and donor_dict to yaml.

        Variables:
        ----------
        file_name: str
            Name of output files.

    load(file_name)
        Load data from json file and return DataSetManager object.

        Variables:
        ----------
        file_name: str
            Name of json file.
        gen_ligand: callable
            Function which returns smiles string of a ligand.
        gen_structure: callable
            Function which generates the structure of a complexe. Returns smiles if structure generation was successfull, else returns False.
        num: int, optional
            Number of complexes. If json file is missing complexes, the missing number of complexes of each category is identified automatically and num_dict is updated accordingly.
        only_SMILES: bool, optional
            If the only_SMILES is set Flase, complexes are not embedded (default True).
        only_LA: bool, optional
            If the only_LA is set to True, fluoride adducts are generated additionaly (default False).
        ligand_poll_factor: int, optional
            The higher the ligand_poll_factor, the more balanced the donor atom count (default 2000).

        Returns:
        --------
        out: DataSetManager object
            A DataSetManager object.
    """

    def __init__(self, num: int, gen_ligand: callable, gen_structure: callable, only_SMILES=False, only_LA=True, ligand_poll_factor=2000) -> None:
        self.num = num  # total amount of complexes to be generated
        self.only_SMILES = only_SMILES
        self.only_LA = only_LA
        self.ligand_poll_factor = ligand_poll_factor
        self.gen_ligand = gen_ligand  # function for ligand generation
        self.gen_structure = gen_structure  # function for structure generation

        self._special = True # set structure distribution; False: even distribution over central atoms; True: even distribution over denticity classes

        # all central atoms and their valencies:
        self.central_atoms = {
            "B": [3],
            "Al": [3],
            "Ga": [3],
            "In": [3],
            "Si": [2, 4],
            "Ge": [2, 4],
            "Sn": [2, 4],
            "Pb": [2, 4],
            "P": [3, 5],
            "As": [3, 5],
            "Sb": [3, 5],
            "Bi": [3, 5],
            "Te": [4],
        }
        # categories of complexes (denticity_class, sub_denticity_class, ligand_class); used for num_dict and donor_dict generation:
        self._structure = {
            "mono": {
                "None": ["None"]
            },
            "bi": {
                "single": ["5", "6", "7"],
                "double": ["55", "56", "57", "66", "67", "77"],
            },
            "tri": {
                "None": [
                    "55",
                    "66",
                    "77",
                    "666",
                    "888",
                    "91010",
                    "101010",
                    "macro_555",
                    "macro_666",
                ]
            },
        }
        # mini ligands; used to fill up valencies of bi- and tri-dentate ligands; the donors of these ligands don't count into donor_dict:
        self._minis = [
            ["[F]", "[Cl]", "[I]", "[H]", "[Br]"],
            ["[O]C"],
            ["[S]C"],
            ["[CH]=C"],
            ["C[N]C"],
            ["[N]=C"],
            ["[CH3]"],
        ]
        # denticity class dict; used to generate file names:
        self._file_name_translation = {"mono": "M", "bi": "B", "tri": "T"}

        # optional additional letter, included in file names:
        self._file_name_letter = ""

        self.data = {}  # data of generated complexes

        self.file_count = 1  # file count (every file name includes a unique number)

        self.gen_empty_num_dict()
        self.gen_num_dict(special=self._special)

        self.gen_empty_donor_dict()
        self.fingerprint_history = set()
        
        if self.num_dict["sum"] != 0:
            print(f"[auto_pams_dm] Data set generation was initialized. {self.num_dict['sum']} structures will be generated.")
        
        return

    @classmethod
    def load(cls, file_name: str, gen_ligand: callable, gen_structure: callable, num: int = 0, only_SMILES=False, only_LA=True, ligand_poll_factor=2000):
        '''
        Load data from json file and return DataSetManager object.
        '''
        # load data from json:
        with open(os.path.join("auto_pams_output", file_name), "r") as f:
            data = json.load(f)
        # gen instance of DataSetManager:
        manager = cls(0, gen_ligand, gen_structure, only_SMILES=only_SMILES, only_LA=only_LA, ligand_poll_factor=ligand_poll_factor)
        # pop fingerprint_history from data:
        fingerprint_history = data.pop("fingerprint_history")
        # update attributes of manager:
        file_count = len(fingerprint_history) + 1
        manager.data = data
        manager.fingerprint_history = set(fingerprint_history)
        manager.file_count = file_count
        for i in data.values():
            manager.add_to_donor_dict(
                i["donors"],
                i["central_atom"],
                i["denticity_class"],
                i["sub_denticity_class"],
                i["ligand_class"],
            )
        DataSetManager.update_donor_dict_sum(manager.donor_dict)

        if num > 0:
            manager.num = num
            manager.gen_num_dict(special=manager._special)
            for i in data.values():
                manager.num_dict[i["central_atom"]][i["denticity_class"]][
                    i["sub_denticity_class"]
                ][i["ligand_class"]] -= 1
            DataSetManager.update_num_dict_sum(manager.num_dict)
            manager.num = manager.num_dict["sum"]
        
        print(f"[auto_pams_dm] Data set generation was initialized from already existing data set. {manager.num_dict['sum']} additional structures will be generated.")
        
        return manager

    def gen_empty_donor_dict(self):
        '''
        Generate an empty donor dict based on ca, dc, sdc and lc structure.
        '''
        # ligands have a fixed set of possible donors:
        my_dict = {
            "OSP3": 0,
            "OSP2": 0,
            "SSP3": 0,
            "SSP2": 0,
            "NSP3": 0,
            "NSP2": 0,
            "CSP3": 0,
            "CSP2": 0,
        }
        # tri-dentate macro-cycle ligands have a limited selection of donors:
        my_dict_macro = {
            "NSP3": 0,
            "NSP2": 0,
            "CSP2": 0,
        }
        # loop donor_dict:
        # 1. loop central atoms
        self.donor_dict = {}
        self.donor_dict["sum"] = {}
        for ca_symbol in self.central_atoms:
            for valence in self.central_atoms[ca_symbol]:
                ca = "".join([ca_symbol, "_", str(valence)])
                self.donor_dict[ca] = {}
                self.donor_dict[ca]["sum"] = {}
                # loop all denticity classes (dc)
                for dc in self._structure:
                    # skip tridentate ligands for central atoms with valence < 3
                    if valence < 3 and dc == "tri":
                        continue
                    self.donor_dict[ca][dc] = {}
                    self.donor_dict[ca][dc]["sum"] = {}
                    # loop all sub denticity classes (sdc)
                    for sdc in self._structure[dc]:
                        # skip double bidentate ligands for central atoms with valence < 4
                        if valence < 4 and (dc, sdc) == ("bi", "double"):
                            continue
                        self.donor_dict[ca][dc][sdc] = {}
                        self.donor_dict[ca][dc][sdc]["sum"] = {}
                        # loop all ligand classes (lc)
                        for lc in self._structure[dc][sdc]:
                            self.donor_dict[ca][dc][sdc][lc] = my_dict.copy()
                            # add extra donor class "monoatomic" for mono-dentate complexes:
                            if dc == "mono":
                                self.donor_dict[ca][dc][sdc][lc]["monoatomic"] = 0
                            # tri-dentate macro-cycles have a other donor atoms:
                            if dc == "tri" and "macro" in lc:
                                self.donor_dict[ca][dc][sdc][lc] = my_dict_macro.copy()
        return

    def gen_empty_num_dict(self):
        '''
        Generate an empty num dict based on ca, dc, sdc and lc structure.
        '''
        self.num_dict = {}
        for ca_symbol in self.central_atoms:
            for valence in self.central_atoms[ca_symbol]:
                ca = "".join([ca_symbol, "_", str(valence)])
                self.num_dict[ca] = {}
                self.num_dict[ca]["sum"] = 0
                # loop all denticity classes (dc)
                for dc in self._structure:
                    # skip tridentate ligands for central atoms with valence < 3
                    if valence < 3 and dc == "tri":
                        continue
                    self.num_dict[ca][dc] = {}
                    self.num_dict[ca][dc]["sum"] = 0
                    # loop all sub denticity classes (sdc)
                    for sdc in self._structure[dc]:
                        # skip double bidentate ligands for central atoms with valence < 4
                        if valence < 4 and (dc, sdc) == ("bi", "double"):
                            continue
                        self.num_dict[ca][dc][sdc] = {}
                        self.num_dict[ca][dc][sdc]["sum"] = 0
                        # loop all ligand classes (lc)
                        for lc in self._structure[dc][sdc]:
                            self.num_dict[ca][dc][sdc][lc] = 0
        return

    def gen_num_dict(self, special=False):
        '''
        Populate a num dict evenly.
        '''
        self.num_dict["sum"] = self.num
        if special:
            # call special distribution:
            DataSetManager.distribute_num_dict_special(self.num_dict)
            # DataSetManager.distribute_num_dict_special skips distribution into central atom categories; hence sums of central atom groups needs to be determined:
            DataSetManager.update_num_dict_sum(self.num_dict)
        else:
            # call normal distribution:
            DataSetManager.distribute_num_dict(self.num_dict)
        return

    def gen_complexes(self):
        '''
        Run complex generation.
        '''
        # loop num_dict
        # 1. loop central atoms
        for ca in self.num_dict:
            if ca == "sum":
                continue
            if self.num_dict[ca]["sum"] == 0:
                print(f"[auto_pams_dm] No {ca} complexes in queue.")
                continue
            print("--------------------------------------------------------------------")
            print(f"[auto_pams_dm] Doing central atom: {ca} (current count: {len(self.fingerprint_history)})")
            print("--------------------------------------------------------------------")
            valence = int(ca.split("_")[1])
            # 2. loop all denticity classes (dc)
            for dc in self.num_dict[ca]:
                if dc == "sum":
                    continue
                if self.num_dict[ca][dc]["sum"] == 0:
                    print(f"    [auto_pams_dm] No {dc}-dentate complexes in queue.")
                    continue
                print(f"    [auto_pams_dm] Doing subclass {dc} (current count: {len(self.fingerprint_history)})")
                # 3. loop all sub denticity classes (sdc)
                for sdc in self.num_dict[ca][dc]:
                    if sdc == "sum":
                        continue
                    # 4. loop all ligand classes (lc)
                    for lc, num in self.num_dict[ca][dc][sdc].items():
                        if lc == "sum":
                            continue
                        # 5. loop number of complexes
                        for _ in range(num):
                            # gen file_name:
                            file_name = "".join(
                                ca
                                + "_"
                                + self._file_name_letter
                                + self._file_name_translation[dc]
                                + f"{self.file_count:06d}"
                            )
                            # gen complex:
                            my_complex = {}
                            my_complex["central_atom"] = ca
                            my_complex["denticity_class"] = dc
                            my_complex["sub_denticity_class"] = sdc
                            my_complex["ligand_class"] = lc
                            while True:
                                # call complex_gen_function:
                                if dc == "mono":
                                    ligands, donors = self.gen_mono_complex(ca, dc, sdc, lc, valence)
                                elif dc == "bi":
                                    ligands, donors = self.gen_bi_complex(ca, dc, sdc, lc, valence)
                                elif dc == "tri":
                                    ligands, donors = self.gen_tri_complex(ca, dc, sdc, lc, valence)
                                else:
                                    raise ValueError(f"Invalid denticity class: {dc}")
                                # check if complex is dublicate:
                                fingerprint = DataSetManager.gen_fingerprint(ca, ligands)
                                if self.check_dublicate(fingerprint):
                                    print("        [auto_pams_dm] Dublicate detected. Retry...")
                                    continue
                                # check if gen_structure successfull:
                                smiles, smiles__F = self.gen_structure(ca, ligands, file_name, only_SMILES=self.only_SMILES, only_LA=self.only_LA)
                                if smiles:
                                    break
                                print("        [auto_pams_dm] Structure generation failed. Retry...")
                            # add fingerprint to fingerprint_history
                            self.fingerprint_history.add(fingerprint)
                            # add complex to data:
                            my_complex["ligands"] = ligands
                            my_complex["donors"] = donors
                            my_complex["smiles"] = smiles
                            my_complex["smiles__F"] = smiles__F
                            my_complex["fingerprint"] = fingerprint
                            self.data[file_name] = my_complex
                            # update donor_dict
                            self.add_to_donor_dict(donors, ca, dc, sdc, lc)
                            # update file_counter
                            self.file_count += 1
            print(f"[auto_pams_dm] Finished {ca}. Autosave ...")
            self.save(f"autosave-file-{self.file_count-1}")
        DataSetManager.update_donor_dict_sum(self.donor_dict)
        return

    def gen_mono_complex(self, ca: str, dc: str, sdc: str, lc: str, valence: int) -> tuple:
        '''
        Sample ligands for a monodentate complex.
        '''
        # get copy of current donor distribution
        current_donor_distribution = self.donor_dict[ca][dc][sdc][lc].copy()
        # create list to save new generated ligands:
        ligands = []
        # create defaultdict to save donors of new generated ligands
        donors = collections.defaultdict(int)
        for _ in range(valence):
            # get excluded_donor and included_donor
            excluded_donor, included_donor = DataSetManager.get_excluded_included(current_donor_distribution)
            # get new ligand
            new_ligand = self.get_ligand(dc, lc, included_donor, excluded_donor)
            # add new ligand to ligands
            ligands.append(new_ligand)
            # get donors of new ligand
            new_donors = DataSetManager.get_donors(new_ligand, expected_num=1)
            # add new donors to current_donor_distribution and donors:
            for key, value in new_donors.items():
                current_donor_distribution[key] += value
                donors[key] += value
        return ligands, dict(donors)

    def gen_bi_complex(self, ca: str, dc: str, sdc: str, lc: str, valence: int) -> list:
        '''
        Sample ligands for a bidentate complex.
        '''
        valence_count = valence
        # get copy of current donor distribution
        current_donor_distribution = self.donor_dict[ca][dc][sdc][lc].copy()
        # create list to save new generated ligands:
        ligands = []
        # create defaultdict to save donors of new generated ligands
        donors = collections.defaultdict(int)
        if sdc == "single":
            # add one bi-dentate ligand:
            # 1. get excluded_donor and included_donor
            excluded_donor, included_donor = DataSetManager.get_excluded_included(current_donor_distribution)
            # 2. get new ligand
            new_ligand = self.get_ligand(dc, lc, included_donor, excluded_donor)
            # 3. add new ligand to ligands
            ligands.append(new_ligand)
            # 4. get donors of new ligand
            new_donors = DataSetManager.get_donors(new_ligand, expected_num=2)
            # 5. add new donors to current_donor_distribution and donors:
            for key, value in new_donors.items():
                current_donor_distribution[key] += value
                donors[key] += value
            # 6. update valence_count
            valence_count -= 2
        elif sdc == "double":
            for i in lc:
                # add one bi-dentate ligand:
                # 1. get excluded_donor and included_donor
                excluded_donor, included_donor = DataSetManager.get_excluded_included(current_donor_distribution)
                # 2. get new ligand
                new_ligand = self.get_ligand(dc, i, included_donor, excluded_donor)
                # 3. add new ligand to ligands
                ligands.append(new_ligand)
                # 4. get donors of new ligand
                new_donors = DataSetManager.get_donors(new_ligand, expected_num=2)
                # 5. add new donors to current_donor_distribution and donors:
                for key, value in new_donors.items():
                    current_donor_distribution[key] += value
                    donors[key] += value
                # 6. update valence_count
                valence_count -= 2
        else:
            raise ValueError(f"Invalid sub denticity class: {sdc}")
        # fill up remaining valencies with mini ligands:
        while valence_count > 0:
            ligands.append(random.choice(random.choice(self._minis)))
            valence_count -= 1
        return ligands, dict(donors)

    def gen_tri_complex(self, ca: str, dc: str, sdc: str, lc: str, valence: int) -> list:
        '''
        Sample ligands for a tridentate complex.
        '''
        valence_count = valence
        # get copy of current donor distribution
        current_donor_distribution = self.donor_dict[ca][dc][sdc][lc].copy()
        # create list to save new generated ligands:
        ligands = []
        # create defaultdict to save donors of new generated ligands
        donors = collections.defaultdict(int)
        # add one tri-dentate ligand:
        # 1. get excluded_donor and included_donor
        excluded_donor, included_donor = DataSetManager.get_excluded_included(current_donor_distribution)
        # 2. get new ligand
        new_ligand = self.get_ligand(dc, lc, included_donor, excluded_donor)
        # 3. add new ligand to ligands
        ligands.append(new_ligand)
        # 4. get donors of new ligand
        new_donors = DataSetManager.get_donors(new_ligand, expected_num=3)
        # 5. add new donors to current_donor_distribution and donors:
        for key, value in new_donors.items():
            current_donor_distribution[key] += value
            donors[key] += value
        # 6. update valence_count
        valence_count -= 3
        # fill up remaining valencies with mini ligands:
        while valence_count > 0:
            ligands.append(random.choice(random.choice(self._minis)))
            valence_count -= 1
        return ligands, dict(donors)

    def add_to_donor_dict(self, donors: dict, ca: str, dc: str, sdc: str, lc: str):
        '''
        Adds donors to donor_dict at given position (position is defined by ca, dc, sdc, lc)
        '''
        for key, value in donors.items():
            self.donor_dict[ca][dc][sdc][lc][key] += value
        return

    def get_ligand(self, dc: str, lc: str, included_donor: str, excluded_donor: str) -> str:
        '''
        Trys to return a ligand which includes included_donor and excluds excluded_donor.
        '''
        max_num_atoms = {"mono": 20, "bi": 50, "tri": 70}
        trys = self.ligand_poll_factor # maximum trys: if maximum trys is reached, a ligand is returned even if it does not match the included_donor and excluded_donor constraint
        donor_num = {
            "mono": 1,
            "bi": 2,
            "tri": 3,
        }  # defines the number of donors for each denticity class
        while trys > 0:
            ligand = self.gen_ligand(dc, lc, max_num_atoms[dc])
            donors = DataSetManager.get_donors(ligand, expected_num=donor_num[dc]) # expected_num is passed additionally, to catch incorrect Chem.MolFromSmiles conversion
            # special case: bi-5, bi-6 and tri-55 ligands:
            # - in those types of ligands CSP3, CSP2 and NSP2 donors are common and are likely to appear together in the same ligand
            # - hence for those types of ligands the normal included_donor and excluded_donor constraint is not sufficient and two excluded_donor are taken into account
            if (
                (dc, lc) == ("bi", "5")
                or (dc, lc) == ("bi", "6")
                or (dc, lc) == ("tri", "55")
            ):
                if (
                    included_donor in donors
                    and not excluded_donor[0] in donors
                    and not excluded_donor[1] in donors
                ):
                    return ligand
                trys -= 1
                continue
            # normal case:
            if included_donor in donors and not excluded_donor[0] in donors:
                return ligand
            trys -= 1
        return ligand

    def check_dublicate(self, fingerprint: str) -> bool:
        '''
        Check if a complex is already in fingerprint_history, based on its fingerprint.
        '''
        return fingerprint in self.fingerprint_history

    def save(self, name: str):
        '''
        Save data to json file, num_dict to yaml and donor_dict to yaml.
        '''
        # Save data to json:
        # 1. add fingerprint_history to data
        self.data["fingerprint_history"] = list(self.fingerprint_history)
        # 2. Save
        with open(os.path.join("auto_pams_output", f"{name}.json"), "w") as f:
            json.dump(self.data, f, indent=4)
        # 3. remove fingerprint_history from data
        self.data.pop("fingerprint_history")
        # Save num_dict to yaml:
        with open(os.path.join("auto_pams_output", f"{name}.num.yaml"), "w") as f:
            yaml.dump(self.num_dict, f)
        # Save donor_dict to yaml:
        with open(os.path.join("auto_pams_output", f"{name}.donors.yaml"), "w") as f:
            yaml.dump(self.donor_dict, f)
        print("[auto_pams_dm] Save successull")
        print()
        return

    ##########################
    #### STATIC FUNCTIONS: ###
    ##########################

    @staticmethod
    def update_donor_dict_sum(donor_dict):
        '''
        Evaluate sums of donors for every complex category.
        '''
        child_donor_dicts = [value for value in donor_dict.values() if "sum" in value.keys()]
        # if a child_donor_dict exists, the lowest layer of donor_dict is not reached; update_donor_dict_sum is called for every child-donor_dict recursively
        if len(child_donor_dicts) > 0:
            for child_donor_dict in child_donor_dicts:
                DataSetManager.update_donor_dict_sum(child_donor_dict)

            my_sum = collections.defaultdict(int)
            for i in child_donor_dicts:
                for key, value in i["sum"].items():
                    my_sum[key] += value
            donor_dict["sum"] = dict(my_sum)
        # if no child_donor_dict exists, the lowest layer of donor_dict is reached
        else:
            my_sum = collections.defaultdict(int)
            my_list = [value for key, value in donor_dict.items() if key != "sum"]
            for i in my_list:
                for key, value in i.items():
                    my_sum[key] += value
            donor_dict["sum"] = dict(my_sum)
        return

    @staticmethod
    def update_num_dict_sum(num_dict):
        '''
        Evaluate sums for every complex category.
        '''
        # get child_num_dicts:
        child_num_dicts = [value for value in num_dict.values() if isinstance(value, dict)]
        # if a child_num_dict exists, the lowest layer of num_dict is not reached; update_num_dict_sum is called for every child-num_dict recursively
        if len(child_num_dicts) > 0:
            for child_num_dict in child_num_dicts:
                DataSetManager.update_num_dict_sum(child_num_dict)
            num_dict["sum"] = sum([i["sum"] for i in child_num_dicts])
        # if no child_num_dics exists, the lowest layer of num_dict is reached
        else:
            num_dict["sum"] = sum([value for key, value in num_dict.items() if key != "sum" and value > 0])
        return

    @staticmethod
    def distribute_num_dict_special(num_dict):
        '''
        Distribute the total amount of complexes over each category recursively.
        Skips distribution into central atom categories.
        Directly distributes into denticity class categories.
        '''
        quantity = num_dict["sum"]
        # directly get child of child_num_dict to skip distribution into central atom categories:
        child_num_dicts = [child_child for child in num_dict.values() if isinstance(child, dict) for child_child in child.values() if isinstance(child_child, dict)]
        categories = len(child_num_dicts)
        distribution = DataSetManager.distribute(quantity, categories)
        for i, child_num_dict in enumerate(child_num_dicts):
            child_num_dict["sum"] = distribution[i]
            DataSetManager.distribute_num_dict(child_num_dict)
        return

    @staticmethod
    def distribute_num_dict(num_dict):
        '''
        Distribute the total amount of complexes over each category recursively.
        '''
        quantity = num_dict["sum"]
        # get child_num_dicts:
        child_num_dicts = [value for value in num_dict.values() if isinstance(value, dict)]
        keys = [key for key, value in num_dict.items() if isinstance(value, int) and key != "sum" ]
        # if a child_num_dict exists, the lowest layer of num_dict is not reached; distribute_num_dict is called for every child-num_dict recursively
        if len(child_num_dicts) > 0:
            categories = len(child_num_dicts)
            distribution = DataSetManager.distribute(quantity, categories)
            for i, child_num_dict in enumerate(child_num_dicts):
                child_num_dict["sum"] = distribution[i]
                DataSetManager.distribute_num_dict(child_num_dict)
        # if no child_num_dics exists, the lowest layer of num_dict is reached
        else:
            categories = len(keys)
            distribution = DataSetManager.distribute(quantity, categories)
            for i, key in enumerate(keys):
                num_dict[key] = distribution[i]
        return

    @staticmethod
    def distribute(quantity: int, categories: int) -> list:
        '''
        Distribute a quantity over a number of categories as evenly as possible.
        '''
        base = quantity // categories
        remainder = quantity % categories
        return [base + (1 if i < remainder else 0) for i in range(categories)]

    @staticmethod
    def get_donors(ligand: str, expected_num: int = 0) -> dict:
        '''
        Count donor atoms of a ligand. The donor atoms are marked by radical electrons.
        The expected amount of donors can be passed additionally to catch incorrect Chem.MolFromSmiles conversion.
        '''
        # special case: mono atomic ligands represent a special donor group:
        if ligand in ["[F]", "[Cl]", "[I]", "[H]", "[Br]"]:
            return {"monoatomic": 1}
        # generall case:
        donors = []
        out = collections.defaultdict(int)
        # gen mol object from smiles string
        mol = Chem.MolFromSmiles(ligand)
        # loop all atoms and find the ones with radical electrons
        for atom in mol.GetAtoms():
            if atom.GetNumRadicalElectrons() == 1:
                donors.append(atom)
        # gen symbol for each donor; C and N are further differentiated by hybridisation type
        for i, atom in enumerate(donors):
            symbol = atom.GetSymbol()
            if atom.GetHybridization() == Chem.rdchem.HybridizationType.SP3:
                symbol += "SP3"
            elif atom.GetHybridization() == Chem.rdchem.HybridizationType.SP2:
                symbol += "SP2"
            else:
                raise ValueError(f"Expected Chem.rdchem.HybridizationType SP3 or SP2, found {atom.GetHybridization()}. Smiles {ligand}")
            donors[i] = symbol
        # count each type of donor
        for i in donors:
            out[i] += 1
        # check if expected amount of donors matches found amount of donors
        if expected_num > 0:
            found_num = len(donors)
            if expected_num != found_num:
                raise ValueError(f"Expected {expected_num} radical atoms, found {found_num} radical atoms. Smiles {ligand}")
        return dict(out)

    @staticmethod
    def gen_fingerprint(ca: str, ligands: list) -> str:
        '''
        Return the fingerprint of a complex.
        A complex is defined by its central atom and its list of ligands.
        '''
        string_list = ligands.copy()
        string_list.append(ca)
        string_list.sort()
        string = "_".join(string_list)
        return hashlib.md5(string.encode()).hexdigest()

    @staticmethod
    def get_excluded_included(donors: dict) -> tuple:
        '''
        Get two most common donors (exclude_donor) and least common donor (included_donor) from donors.
        '''
        donors = donors.copy()
        included_donor = list(donors.keys())[list(donors.values()).index(min(list(donors.values())))]
        excluded_donor_1 = list(donors.keys())[list(donors.values()).index(max(list(donors.values())))]
        donors.pop(excluded_donor_1)
        excluded_donor_2 = list(donors.keys())[list(donors.values()).index(max(list(donors.values())))]
        return ((excluded_donor_1, excluded_donor_2), included_donor)
